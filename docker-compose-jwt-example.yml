# Docker Compose Beispiel für JWT-basierte PostgREST-Authentifizierung
# Dieses Beispiel zeigt, wie PostgREST mit JWT-Secret konfiguriert wird

version: '3.8'

services:
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: chef_numbers
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: KnJXQbu7E29g7nKt  # ← Das Passwort für JWT-Secret-Generierung
    ports:
      - "5432:5432"  # ← Externer Port 5433, interner Port 5432
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init-scripts:/docker-entrypoint-initdb.d
    command: |
      sh -c "
        # Starte PostgreSQL im Hintergrund
        docker-entrypoint.sh postgres &
        POSTGRES_PID=\$!
        
        # Warte bis PostgreSQL bereit ist
        until pg_isready -U postgres -d postgres; do
          echo 'Warte auf PostgreSQL...'
          sleep 2
        done
        
        echo 'PostgreSQL ist bereit!'
        echo 'PostgreSQL läuft auf: 0.0.0.0:5432'
        echo 'Datenbank: chef_numbers'
        echo 'Benutzer: postgres'
        
        # Lade Init-Script von der App herunter
        echo 'Lade Init-Script von der App...'
        wget -O /tmp/init-chef-numbers.sql http://192.168.1.20:3000/init-scripts/init-chef-numbers.sql
        
        # Führe Init-Script aus (erst in postgres-Datenbank, dann in chef_numbers)
        echo 'Führe Init-Script aus...'
        psql -U postgres -d postgres -f /tmp/init-chef-numbers.sql
        
        # Warte auf PostgreSQL-Prozess
        wait \$POSTGRES_PID
      "
    networks:
      - chef_network

  postgrest:
    image: postgrest/postgrest
    environment:
      # PostgreSQL-Verbindung (interner Port 5432)
      PGRST_DB_URI: postgres://postgres:KnJXQbu7E29g7nKt@postgres:5432/chef_numbers
      
      # JWT-Konfiguration (aus PostgreSQL-Passwort generiert)
      PGRST_JWT_SECRET: FA963BC9DA1970662093609D3FDB7DAFC08512C4F3D2A962A981BDF273CE7008
      PGRST_JWT_SECRET_IS_BASE64: false
      
      # Schema-Konfiguration
      PGRST_DB_SCHEMAS: public
      PGRST_DB_ANON_ROLE: anon
      PGRST_DB_AUTHENTICATOR_ROLE: authenticator
      
      # Server-Konfiguration
      #PGRST_SERVER_HOST: 0.0.0.0
      #PGRST_SERVER_PORT: 3002
      #PGRST_SERVER_UNIX_SOCKET: /tmp/pgrst.sock
      
      # CORS-Konfiguration
      PGRST_SERVER_CORS_ALLOWED_ORIGINS: "http://localhost:3000,http://127.0.0.1:3000"
      PGRST_SERVER_CORS_ALLOWED_METHODS: "GET, POST, PUT, PATCH, DELETE, OPTIONS"
      PGRST_SERVER_CORS_ALLOWED_HEADERS: "Authorization, Content-Type, Accept, Prefer"
      
      # Logging
      PGRST_LOG_LEVEL: info
    ports:
      - "5433:3000"
    depends_on:
      - postgres
    networks:
      - chef_network

volumes:
  postgres_data:

networks:
  chef_network:
    driver: bridge

# Anleitung zur JWT-Secret-Generierung:
# 
# 1. Frontend (JavaScript):
#    const password = "postgres123";
#    const jwtSecret = await generateJWTSecretFromPassword(password);
#    console.log("JWT_SECRET:", jwtSecret);
#
# 2. Shell (Linux/Mac):
#    echo -n "postgres123" | sha256sum | cut -d' ' -f1
#
# 3. PowerShell (Windows):
#    $password = "postgres123"
#    $bytes = [System.Text.Encoding]::UTF8.GetBytes($password)
#    $hash = [System.Security.Cryptography.SHA256]::Create().ComputeHash($bytes)
#    $jwtSecret = [System.BitConverter]::ToString($hash) -replace '-', ''
#    Write-Host "JWT_SECRET: $jwtSecret"
#
# Alle drei Methoden sollten das gleiche Ergebnis liefern!
# Für "postgres123" ist das Ergebnis: B298CF0838BC3D35B57141F3B249DD1A7C7233B9EF8ED5F94DBFF68444BE8162
#
# WICHTIG: Hardcoded-Konfiguration für Tests auf Remote-Server
# - Server: 192.168.1.7
# - PostgreSQL-Port: 5433 (extern) → 5432 (intern)
# - PostgREST-Port: 3002 (extern) → 3002 (intern)
# - Datenbank: chef_numbers
# - Benutzer: postgres
# - Passwort: postgres123
# - JWT-Secret: B298CF0838BC3D35B57141F3B249DD1A7C7233B9EF8ED5F94DBFF68444BE8162
#
# Frontend-Verbindungen:
# - PostgreSQL: 192.168.1.7:5433
# - PostgREST: 192.168.1.7:3002
#
# Später wird das mit Umgebungsvariablen und Generator gemacht!

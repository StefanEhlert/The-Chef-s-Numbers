version: '3.8'

services:
  # PostgreSQL Database
  postgres:
    image: postgres:15-alpine
    container_name: chef_numbers_postgres
    environment:
      POSTGRES_DB: chef_numbers
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres123
      POSTGRES_INITDB_ARGS: "--encoding=UTF-8 --lc-collate=C --lc-ctype=C"
      # Deaktiviere Kerberos für einfache Authentifizierung
      POSTGRES_HOST_AUTH_METHOD: "md5"
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    command: |
      sh -c "
        # Starte PostgreSQL im Hintergrund
        docker-entrypoint.sh postgres &
        POSTGRES_PID=\$!
        
        # Warte bis PostgreSQL bereit ist
        until pg_isready -U postgres -d postgres; do
          echo 'Warte auf PostgreSQL...'
          sleep 2
        done
        
        # Lade Init-Script von der App herunter
        echo 'Lade Init-Script von der App...'
        wget -O /docker-entrypoint-initdb.d/init-chef-numbers.sql http://192.168.1.20:3000/init-scripts/init-chef-numbers.sql
        
        # Führe Init-Script aus
        echo 'Führe Init-Script aus...'
        psql -U postgres -d postgres -f /docker-entrypoint-initdb.d/init-chef-numbers.sql
        
        # Warte auf PostgreSQL-Prozess
        wait \$POSTGRES_PID
      "
    # DEBUGGING: Entferne command für manuellen Start
    # command: |
    #   sh -c "
    #     echo '=== PostgreSQL Container Start ==='
    #     
    #     # Starte PostgreSQL im Hintergrund
    #     echo 'Starte PostgreSQL...'
    #     docker-entrypoint.sh postgres &
    #     POSTGRES_PID=\$!
    #     
    #     # Warte bis PostgreSQL bereit ist
    #     echo 'Warte auf PostgreSQL...'
    #     for i in {1..30}; do
    #       if pg_isready -U postgres -d postgres; then
    #         echo 'PostgreSQL ist bereit!'
    #         break
    #       fi
    #       echo \"Warte... (\$i/30)\"
    #       sleep 2
    #     done
    #     
    #     # Teste Verbindung zur App
    #     echo 'Teste Verbindung zur App...'
    #     if wget --timeout=10 --tries=3 -O /tmp/init-chef-numbers.sql http://192.168.1.20:3000/init-chef-numbers.sql; then
    #       echo 'Init-Script erfolgreich heruntergeladen!'
    #       echo 'Führe Init-Script aus...'
    #       if psql -U postgres -d postgres -f /tmp/init-chef-numbers.sql; then
    #         echo 'Init-Script erfolgreich ausgeführt!'
    #       else
    #         echo 'FEHLER: Init-Script-Ausführung fehlgeschlagen!'
    #         exit 1
    #       fi
    #     else
    #       echo 'FEHLER: Download des Init-Scripts fehlgeschlagen!'
    #       echo 'Verwende Fallback...'
    #       psql -U postgres -d postgres -c 'CREATE ROLE anon NOLOGIN;' || true
    #       psql -U postgres -d postgres -c 'CREATE ROLE authenticated NOLOGIN;' || true
    #       psql -U postgres -d postgres -c 'CREATE ROLE service_role NOLOGIN;' || true
    #     fi
    #     
    #     echo '=== PostgreSQL Container bereit ==='
    #     
    #     # Warte auf PostgreSQL-Prozess
    #     wait \$POSTGRES_PID
    #   "
    networks:
      - chef_network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d chef_numbers || exit 1"]
      interval: 15s
      timeout: 10s
      retries: 10
      start_period: 60s

  # PostgREST API mit CORS-Unterstützung
  postgrest:
    image: postgrest/postgrest:v11.2.0
    container_name: chef_numbers_postgrest
    environment:
      PGRST_DB_URI: postgres://postgres:postgres123@postgres:5432/chef_numbers
      PGRST_DB_SCHEMAS: public
      PGRST_DB_ANON_ROLE: postgres
      PGRST_DB_USE_LEGACY_GUCS: "false"
      PGRST_JWT_SECRET: "your-super-secret-jwt-token-with-at-least-32-characters-long-for-security"
      PGRST_CORS_ALLOWED_ORIGINS: "*"
      PGRST_CORS_ALLOWED_METHODS: "GET, POST, PUT, PATCH, DELETE, OPTIONS"
      PGRST_CORS_ALLOWED_HEADERS: "Content-Type, Authorization, X-Requested-With"
      PGRST_CORS_EXPOSED_HEADERS: "Content-Range, Content-Location"
      PGRST_CORS_ALLOW_CREDENTIALS: "true"
      PGRST_CORS_MAX_AGE: "3600"
      # Deaktiviere Kerberos für einfache Authentifizierung
      PGRST_DB_EXTRA_SEARCH_PATH: "public"
    ports:
      - "5433:3000"
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - chef_network
    # Health-Check deaktiviert - PostgREST zeigt immer "unhealthy" an
    # healthcheck:
    #   test: ["CMD-SHELL", "curl -f http://localhost:3000/rpc/api_check_schema_status || exit 1"]
    #   interval: 30s
    #   timeout: 10s
    #   retries: 5
    #   start_period: 40s

  # MinIO Object Storage
  minio:
    image: minio/minio:latest
    container_name: chef_numbers_minio
    environment:
      MINIO_ROOT_USER: Admin
      MINIO_ROOT_PASSWORD: obfMAaPB2cpM98xG
    ports:
      - "9000:9000"
      - "9001:9001"
    volumes:
      - minio_data:/data
    networks:
      - chef_network
    command: server /data --console-address ":9001"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 30s
      timeout: 20s
      retries: 3
      start_period: 30s

volumes:
  postgres_data:
    driver: local
  minio_data:
    driver: local

networks:
  chef_network:
    driver: bridge
// Automatische Schema-Migration zur Laufzeit
// Vergleicht aktuelles Datenbankschema mit TypeScript-Interfaces und f√ºhrt Migrationen durch

export interface Migration {
  type: 'ADD_COLUMN' | 'ALTER_COLUMN' | 'DROP_COLUMN' | 'ADD_TABLE' | 'DROP_TABLE';
  table: string;
  column?: {
    name: string;
    type: string;
    nullable: boolean;
    defaultValue?: any;
    description: string;
  };
  description: string;
}

export interface DatabaseColumn {
  name: string;
  type: string;
  nullable: boolean;
  defaultValue?: any;
  description: string;
}

export interface DatabaseTable {
  name: string;
  columns: DatabaseColumn[];
}

export interface DatabaseSchema {
  tables: DatabaseTable[];
  version?: string;
  hash?: string;
}

export class SchemaMigrationService {
  private currentSchema: DatabaseSchema | null = null;
  private targetSchema: DatabaseSchema | null = null;

  constructor() {
    console.log('üîß SchemaMigrationService initialisiert');
  }

  /**
   * L√§dt das aktuelle Datenbankschema
   */
  async loadCurrentDatabaseSchema(): Promise<DatabaseSchema> {
    try {
      // Hier w√ºrde normalerweise eine Datenbank-Abfrage stattfinden
      // F√ºr jetzt simulieren wir ein leeres Schema
      const schema: DatabaseSchema = {
        tables: [],
        version: '0.0.0',
        hash: 'empty'
      };

      console.log('üìä Aktuelles Datenbankschema geladen');
      this.currentSchema = schema;
      return schema;
    } catch (error) {
      console.error('‚ùå Fehler beim Laden des aktuellen Schemas:', error);
      throw error;
    }
  }

  /**
   * L√§dt das Ziel-Schema aus TypeScript-Interfaces
   */
  async loadTargetSchemaFromInterfaces(): Promise<DatabaseSchema> {
    try {
      // Importiere automatisch generierte Schema-Definitionen
      const { AUTO_GENERATED_SCHEMA_DEFINITIONS } = await import('../schemas/generated/autoGeneratedSchema');
      
      // Konvertiere zu DatabaseSchema-Format
      const tables: DatabaseTable[] = Object.values(AUTO_GENERATED_SCHEMA_DEFINITIONS).map(def => ({
        name: def.tableName,
        columns: def.columns.map(col => ({
          name: col.name,
          type: col.type,
          nullable: col.nullable,
          defaultValue: col.defaultValue,
          description: col.description || `${col.name} property`
        }))
      }));

      const schema: DatabaseSchema = {
        tables,
        version: '1.0.0', // Wird aus Build-Info generiert
        hash: 'auto-generated'
      };

      console.log('üéØ Ziel-Schema aus Interfaces geladen');
      this.targetSchema = schema;
      return schema;
    } catch (error) {
      console.error('‚ùå Fehler beim Laden des Ziel-Schemas:', error);
      throw error;
    }
  }

  /**
   * Generiert Migrations-Skripte basierend auf Schema-Unterschieden
   */
  generateMigrations(currentSchema: DatabaseSchema, targetSchema: DatabaseSchema): Migration[] {
    const migrations: Migration[] = [];
    
    console.log('üîç Analysiere Schema-Unterschiede...');

    // Finde neue Tabellen
    const currentTableNames = new Set(currentSchema.tables.map(t => t.name));
    const targetTableNames = new Set(targetSchema.tables.map(t => t.name));

    // Neue Tabellen hinzuf√ºgen
    targetSchema.tables.forEach(targetTable => {
      if (!currentTableNames.has(targetTable.name)) {
        migrations.push({
          type: 'ADD_TABLE',
          table: targetTable.name,
          description: `Neue Tabelle ${targetTable.name} hinzuf√ºgen`
        });

        // Spalten f√ºr neue Tabelle hinzuf√ºgen
        targetTable.columns.forEach(column => {
          migrations.push({
            type: 'ADD_COLUMN',
            table: targetTable.name,
            column: {
              name: column.name,
              type: column.type,
              nullable: column.nullable,
              defaultValue: column.defaultValue,
              description: column.description || `${column.name} property`
            },
            description: `Spalte ${column.name} zu Tabelle ${targetTable.name} hinzuf√ºgen`
          });
        });
      }
    });

    // Bestehende Tabellen analysieren
    currentSchema.tables.forEach(currentTable => {
      const targetTable = targetSchema.tables.find(t => t.name === currentTable.name);
      
      if (targetTable) {
        // Spalten vergleichen
        const currentColumnNames = new Set(currentTable.columns.map(c => c.name));
        const targetColumnNames = new Set(targetTable.columns.map(c => c.name));

        // Neue Spalten hinzuf√ºgen
        targetTable.columns.forEach(targetColumn => {
          if (!currentColumnNames.has(targetColumn.name)) {
            migrations.push({
              type: 'ADD_COLUMN',
              table: currentTable.name,
              column: {
                name: targetColumn.name,
                type: targetColumn.type,
                nullable: targetColumn.nullable,
                defaultValue: targetColumn.defaultValue,
                description: targetColumn.description || `${targetColumn.name} property`
              },
              description: `Spalte ${targetColumn.name} zu Tabelle ${currentTable.name} hinzuf√ºgen`
            });
          } else {
            // Spalte existiert, pr√ºfe auf √Ñnderungen
            const currentColumn = currentTable.columns.find(c => c.name === targetColumn.name);
            if (currentColumn && this.hasColumnChanged(currentColumn, targetColumn)) {
              migrations.push({
                type: 'ALTER_COLUMN',
                table: currentTable.name,
                column: {
                  name: targetColumn.name,
                  type: targetColumn.type,
                  nullable: targetColumn.nullable,
                  defaultValue: targetColumn.defaultValue,
                  description: targetColumn.description || `${targetColumn.name} property`
                },
                description: `Spalte ${targetColumn.name} in Tabelle ${currentTable.name} √§ndern`
              });
            }
          }
        });

        // Entfernte Spalten (optional - normalerweise nicht automatisch gel√∂scht)
        // currentTable.columns.forEach(currentColumn => {
        //   if (!targetColumnNames.has(currentColumn.name)) {
        //     migrations.push({
        //       type: 'DROP_COLUMN',
        //       table: currentTable.name,
        //       column: {
        //         name: currentColumn.name,
        //         type: currentColumn.type,
        //         nullable: currentColumn.nullable,
        //         defaultValue: currentColumn.defaultValue,
        //         description: currentColumn.description
        //       },
        //       description: `Spalte ${currentColumn.name} aus Tabelle ${currentTable.name} entfernen`
        //     });
        //   }
        // });
      }
    });

    // Entfernte Tabellen (optional - normalerweise nicht automatisch gel√∂scht)
    // currentSchema.tables.forEach(currentTable => {
    //   if (!targetTableNames.has(currentTable.name)) {
    //     migrations.push({
    //       type: 'DROP_TABLE',
    //       table: currentTable.name,
    //       description: `Tabelle ${currentTable.name} entfernen`
    //     });
    //   }
    // });

    console.log(`üìã ${migrations.length} Migrationen generiert`);
    return migrations;
  }

  /**
   * Pr√ºft ob sich eine Spalte ge√§ndert hat
   */
  private hasColumnChanged(current: DatabaseColumn, target: DatabaseColumn): boolean {
    return (
      current.type !== target.type ||
      current.nullable !== target.nullable ||
      current.defaultValue !== target.defaultValue
    );
  }

  /**
   * F√ºhrt eine Migration aus
   */
  async executeMigration(migration: Migration): Promise<boolean> {
    try {
      console.log(`üîÑ F√ºhre Migration aus: ${migration.description}`);

      switch (migration.type) {
        case 'ADD_COLUMN':
          await this.addColumn(migration.table, migration.column!);
          break;
        case 'ALTER_COLUMN':
          await this.alterColumn(migration.table, migration.column!);
          break;
        case 'ADD_TABLE':
          await this.addTable(migration.table);
          break;
        case 'DROP_COLUMN':
          await this.dropColumn(migration.table, migration.column!.name);
          break;
        case 'DROP_TABLE':
          await this.dropTable(migration.table);
          break;
        default:
          console.warn(`‚ö†Ô∏è Unbekannter Migrationstyp: ${migration.type}`);
          return false;
      }

      console.log(`‚úÖ Migration erfolgreich: ${migration.description}`);
      return true;
    } catch (error) {
      console.error(`‚ùå Migration fehlgeschlagen: ${migration.description}`, error);
      return false;
    }
  }

  /**
   * F√ºgt eine Spalte zu einer Tabelle hinzu
   */
  private async addColumn(tableName: string, column: DatabaseColumn): Promise<void> {
    // Hier w√ºrde normalerweise eine SQL-Ausf√ºhrung stattfinden
    console.log(`  ‚ûï Spalte ${column.name} (${column.type}) zu ${tableName} hinzuf√ºgen`);
    
    // Simuliere SQL-Ausf√ºhrung
    const sql = `ALTER TABLE ${tableName} ADD COLUMN ${column.name} ${column.type} ${column.nullable ? '' : 'NOT NULL'}`;
    console.log(`  üìù SQL: ${sql}`);
  }

  /**
   * √Ñndert eine Spalte in einer Tabelle
   */
  private async alterColumn(tableName: string, column: DatabaseColumn): Promise<void> {
    console.log(`  üîÑ Spalte ${column.name} in ${tableName} √§ndern`);
    
    // Simuliere SQL-Ausf√ºhrung
    const sql = `ALTER TABLE ${tableName} ALTER COLUMN ${column.name} TYPE ${column.type}`;
    console.log(`  üìù SQL: ${sql}`);
  }

  /**
   * F√ºgt eine neue Tabelle hinzu
   */
  private async addTable(tableName: string): Promise<void> {
    console.log(`  ‚ûï Tabelle ${tableName} hinzuf√ºgen`);
    
    // Simuliere SQL-Ausf√ºhrung
    const sql = `CREATE TABLE ${tableName} (id SERIAL PRIMARY KEY)`;
    console.log(`  üìù SQL: ${sql}`);
  }

  /**
   * Entfernt eine Spalte aus einer Tabelle
   */
  private async dropColumn(tableName: string, columnName: string): Promise<void> {
    console.log(`  ‚ûñ Spalte ${columnName} aus ${tableName} entfernen`);
    
    // Simuliere SQL-Ausf√ºhrung
    const sql = `ALTER TABLE ${tableName} DROP COLUMN ${columnName}`;
    console.log(`  üìù SQL: ${sql}`);
  }

  /**
   * Entfernt eine Tabelle
   */
  private async dropTable(tableName: string): Promise<void> {
    console.log(`  ‚ûñ Tabelle ${tableName} entfernen`);
    
    // Simuliere SQL-Ausf√ºhrung
    const sql = `DROP TABLE ${tableName}`;
    console.log(`  üìù SQL: ${sql}`);
  }

  /**
   * Hauptfunktion: Pr√ºft und migriert das Schema
   */
  async checkAndMigrate(): Promise<{
    success: boolean;
    migrationsExecuted: number;
    migrationsFailed: number;
    message: string;
  }> {
    try {
      console.log('üöÄ Starte Schema-Migration...');

      // Lade aktuelle und Ziel-Schemata
      const currentSchema = await this.loadCurrentDatabaseSchema();
      const targetSchema = await this.loadTargetSchemaFromInterfaces();

      // Generiere Migrationen
      const migrations = this.generateMigrations(currentSchema, targetSchema);

      if (migrations.length === 0) {
        console.log('‚úÖ Schema ist aktuell - keine Migrationen erforderlich');
        return {
          success: true,
          migrationsExecuted: 0,
          migrationsFailed: 0,
          message: 'Schema ist aktuell'
        };
      }

      console.log(`üìã ${migrations.length} Migrationen gefunden`);

      // F√ºhre Migrationen aus
      let executed = 0;
      let failed = 0;

      for (const migration of migrations) {
        const success = await this.executeMigration(migration);
        if (success) {
          executed++;
        } else {
          failed++;
        }
      }

      console.log(`‚úÖ Migration abgeschlossen: ${executed} erfolgreich, ${failed} fehlgeschlagen`);

      return {
        success: failed === 0,
        migrationsExecuted: executed,
        migrationsFailed: failed,
        message: `${executed} Migrationen erfolgreich ausgef√ºhrt`
      };

    } catch (error) {
      console.error('‚ùå Fehler bei Schema-Migration:', error);
      return {
        success: false,
        migrationsExecuted: 0,
        migrationsFailed: 1,
        message: `Fehler: ${error}`
      };
    }
  }

  /**
   * Validiert das aktuelle Schema gegen die Interfaces
   */
  async validateSchema(): Promise<{
    valid: boolean;
    errors: string[];
    warnings: string[];
  }> {
    try {
      const currentSchema = await this.loadCurrentDatabaseSchema();
      const targetSchema = await this.loadTargetSchemaFromInterfaces();
      const migrations = this.generateMigrations(currentSchema, targetSchema);

      const errors: string[] = [];
      const warnings: string[] = [];

      if (migrations.length > 0) {
        warnings.push(`${migrations.length} Schema-Unterschiede gefunden`);
        
        migrations.forEach(migration => {
          if (migration.type === 'ADD_TABLE' || migration.type === 'ADD_COLUMN') {
            warnings.push(`Fehlend: ${migration.description}`);
          }
        });
      }

      return {
        valid: errors.length === 0,
        errors,
        warnings
      };

    } catch (error) {
      return {
        valid: false,
        errors: [`Validierungsfehler: ${error}`],
        warnings: []
      };
    }
  }
}

// Singleton-Instanz
export const schemaMigrationService = new SchemaMigrationService();
